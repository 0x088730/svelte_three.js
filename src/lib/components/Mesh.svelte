<!--
`accessors:true` hast to be set per component because of the svelte-language-server bug, otherwise accessors would be falsely detected as missing and highlighted as errors.
svelthree uses svelte-accmod, where accessors are always `true`, regardless of `svelte:options`.  
-->
<svelte:options accessors />

<!--
@component
**svelthree** _Mesh_ Component.
[ tbd ]  Link to Docs.
-->
<script lang="ts">
	import type { Scene as THREE_Scene } from "three"

	import { beforeUpdate, onMount, afterUpdate, onDestroy, getContext, setContext, tick } from "svelte"
	import { get_current_component } from "svelte/internal"
	import { self as _self } from "svelte/internal"
	import { c_rs, c_lc, c_mau, c_dev, verbose_mode, get_comp_name } from "../utils/SvelthreeLogger"
	import type { LogLC, LogDEV } from "../utils/SvelthreeLogger"
	import type { SvelthreeShadowDOMElement } from "../types/types-extra"
	import { if$_instance_change } from "../logic/if$"
	import { remove_instance, recreate_shadow_dom_el, set_initial_userdata, find_in_canvas } from "../logic/shared"

	import type { Euler, Matrix4, Quaternion, Vector3 } from "three"
	import type { Object3D as THREE_Object3D } from "three"

	import { svelthreeStores } from "svelthree/stores"
	import { PropUtils, SvelthreeProps } from "../utils"

	import { SvelthreeAnimation } from "../ani"
	import type { SvelthreeAnimationFunction } from "../types/types-extra"

	import SvelthreeInteraction from "../components-internal/SvelthreeInteraction.svelte"
	import type { RaycastArray } from "../utils/RaycastArray"
	import { createEventDispatcher } from "svelte"
	import type { Writable } from "svelte/store"

	import type { SvelthreeModifiersProp } from "../constants/Interaction"
	import type {
		SvelthreePointerEventHandler,
		SvelthreeFocusEventHandler,
		SvelthreeKeyboardEventHandler,
		SvelthreeWheelEventHandler
	} from "../constants/Interaction"

	import { BoxHelper } from "three"
	import { get_root_scene } from "../utils/SceneUtils"

	import type { BufferGeometry } from "three"

	import { Mesh as THREE_Mesh } from "three"
	import type { MeshProperties } from "../types/types-comp-props"
	import type { RemoveFirst, Mat, MeshAssignableMaterial } from "../types/types-extra"
	import type { ButtonProperties, LinkProperties } from "../types/types-comp-props"
	import type { Material } from "three"

	/**
	 *  SVELTEKIT  SSR /
	 * `browser` is needed for the SvelteKit setup (SSR / CSR / SPA).
	 * For non-SSR output in RollUp only and Vite only setups (CSR / SPA) we're just mimicing `$app/env` where `browser = true`,
	 * -> TS fix: `$app/env` mapped to `src/$app/env` via svelthree's `tsconfig.json`'s `path` property.
	 * -> RollUp only setup: replace `$app/env` with `../$app/env`
	 * The import below will work out-of-the-box in a SvelteKit setup.
	 */
	import { browser } from "$app/env"

	const self = get_current_component()
	const c_name = get_comp_name(self)
	/** svelthree component's type (e.g. component `Foo` is of type 'Foo' etc.) */
	export const type: string = c_name

	const verbose: boolean = verbose_mode()

	export let log_all = false
	export let log_dev: { [P in keyof LogDEV]: LogDEV[P] } = log_all ? { all: true } : undefined
	export let log_rs: boolean = log_all
	export let log_lc: { [P in keyof LogLC]: LogLC[P] } = log_all ? { all: true } : undefined
	export let log_mau: boolean = log_all

	const dispatch = createEventDispatcher()

	let scene: THREE_Scene = getContext("scene")
	const sti: number = getContext("store_index")

	/** [ **feature**: allow providing (_injection_) of (_already created_) threejs object instances ].
	 * `create` is an internal indicator for how the component's corresponding threejs object instance has to be / has been created.
	 * It's being set to `false` on initialization if an (_already created_) threejs object instance was provided,
	 * otherwise it's set to `true`, means a new threejs object instance will be created. */
	let create = false

	/** The (three) instance that was shared to this component as it's 'parent' which can be either another instance / object or a scene / root scene. */
	let our_parent: THREE_Object3D = undefined

	/** Shadow DOM element generated by our parent scene / root scene. Used as fallback if this component has no non-`Scene` component as parent. */
	let scene_shadow_dom_el: SvelthreeShadowDOMElement = getContext("scene_shadow_dom_el")

	/** Shadow DOM element generated by our parent component (_not `Canvas`_) shared with this component (child) via context.
	Fallback is `scene_shadow_dom_el` or `shadow_root_el` in case of the `Scene` component. */
	let our_parent_shadow_dom_el: SvelthreeShadowDOMElement = undefined

	/** Shadow DOM element generated by this component. Shared by this component (as parent) to it's children via context as "parent_shadow_dom_el". */
	let shadow_dom_el: SvelthreeShadowDOMElement = undefined
	export const get_shadow_dom_el = (): SvelthreeShadowDOMElement => shadow_dom_el

	/** Specify the component / three.js object instance to act as an HTML `<button>` element. */
	export let button: ButtonProperties = undefined

	/** Specify the component / three.js object instance to act as an HTML `<a>` element. */
	export let link: LinkProperties = undefined

	/** Returns the `mesh` instance created by the component & allows providing (_injection_) of (_already created / premade_) `THREE.Mesh` instances. */
	export let mesh: THREE_Mesh = undefined
	let mesh_uuid: string = undefined

	/** Sets the `name` property of the created / injected three.js instance. */
	export let name: string = undefined

	// Generic Material type
	// COOL!  This is possible now! see https://github.com/sveltejs/language-tools/issues/442#issuecomment-977803507
	// 'mat' shorthand attribute will give us proper intellisense (props list) for the assigned 'material'!
	//  TODO : Implement handling of multiple `Material`s, atm only single `Material` is supported.
	type AssignedMaterial = $$Generic<MeshAssignableMaterial>

	let extracted_material: MeshAssignableMaterial = undefined
	export let material: MeshAssignableMaterial = undefined
	let material_ref: MeshAssignableMaterial = undefined

	let extracted_geometry: BufferGeometry = undefined
	export let geometry: BufferGeometry = undefined
	let geometry_ref: BufferGeometry = undefined

	export const is_svelthree_component = true
	export const is_svelthree_mesh = true

	//  ONCE  ON  INITIALIZATION  //

	if (mesh) {
		create = false
		on_instance_provided()
	} else {
		create = true
	}

	//  INJECTION  ONCE  ON  INITIALIZATION  //

	/** Executed when / if an instance was provided **on initializiation** -> only once if at all! */
	function on_instance_provided(): void {
		if (mesh.type === "Mesh") {
			if (!mesh.geometry) {
				throw new Error(`SVELTHREE > ${c_name} : provided 'mesh' instance has no geometry!`)
			}

			if (!mesh.material) {
				throw new Error(`SVELTHREE > ${c_name} : provided 'mesh' instance has no material!`)
			}
		} else {
			throw new Error(
				`SVELTHREE > ${c_name} provided 'mesh' instance has wrong type '${mesh.type}', should be '${c_name}'!`
			)
		}
	}

	//  INJECTION  ONCE  ON  INITIALIZATION  //

	if (!create) {
		// get the instance that was shared to us as our 'parent' or use fallback.

		our_parent = getContext("parent") || scene
		// get the shadow DOM element that was shared to us by our parent component or use fallback.

		our_parent_shadow_dom_el = getContext("parent_shadow_dom_el") || scene_shadow_dom_el

		// share created object (three) instance to all children (slots) as 'parent'.
		setContext("parent", mesh)

		// SVELTEKIT  SSR /
		if (browser) create_shadow_dom()
	}

	//  CREATION  ONCE  AFTER  INITIALIZATION //

	/** Initializes `Mesh` with provided constructor parameters.*/
	export let params: ConstructorParameters<typeof THREE_Mesh> = undefined

	$: if (!mesh && create) {
		if (geometry && material) {
			if (params?.length)
				console.error(
					`SVELTHREE Error > ${c_name} : You've set 'geometry', 'material' & 'params' -> specified 'params' will be ignored! Please use either 'geometry' & 'material' or 'params' for initialization.`
				)

			// letting threejs throw errors if anything's wrong with 'geometry' or 'material'
			mesh = new THREE_Mesh(geometry, material)

			if (verbose && log_dev) console.debug(...c_dev(c_name, `${geometry.type} created!`, { mesh }))
			if (verbose && log_dev) console.debug(...c_dev(c_name, "saved 'geometry' (created):", geometry))
			if (verbose && log_dev) console.debug(...c_dev(c_name, "saved 'material' (created):", material))
		} else {
			// create 'mesh' via params (can be an empty []) or if no 'params' set (undefined) via new THREE_Mesh()

			// create with params -> since 'geometry' & 'material' are optional, params can also be empty []!
			if (params) {
				// disallow 'params' with 'geometry' or 'material'
				if (geometry)
					throw new Error(
						`SVELTHREE Error > ${c_name} : You've set 'geometry' & 'params' -> specified 'geometry' will be ignored! Please use either 'geometry' & 'material' or 'params' for initialization.`
					)
				if (material)
					throw new Error(
						`SVELTHREE Error > ${c_name} : You've set 'material' & 'params' -> specified 'material' will be ignored! Please use either 'geometry' & 'material' or 'params' for initialization.`
					)

				if (params.length) {
					// letting threejs throw errors if anything's wrong with provided 'params'
					mesh = new THREE_Mesh(...params)
				} else {
					// will create a blank 'BufferGeometry' and a blank Material
					mesh = new THREE_Mesh()
				}
			} else if (geometry === null || material === null) {
				// was cleared -> nothing, don't create a new one
				//console.warn(`SVELTHREE > component was cleared before, won't create a new / blank Mesh!`)
			} else {
				// no 'geometry', no 'material' and no 'params'
				// will create a blank 'BufferGeometry' or a blank Material or both.
				mesh = new THREE_Mesh(geometry, material)
			}

			if (verbose && log_dev) console.debug(...c_dev(c_name, `${geometry.type} created!`, { mesh }))
		}
	}

	// ---  AFTER  INITIALIZATION  --- //

	// set mesh_uuid the first time
	$: if (mesh && mesh_uuid === undefined) set_uuid()

	function set_uuid(): void {
		mesh_uuid = mesh.uuid
	}

	let changed = []

	$: if (mesh || material || geometry) reset_changed_status()

	function reset_changed_status() {
		changed.length = 0
	}

	$: if (mesh) extract()

	function extract() {
		extracted_geometry = mesh.geometry as BufferGeometry
		extracted_material = mesh.material as MeshAssignableMaterial
	}

	$: if (geometry) on_geometry()

	function on_geometry() {
		changed.push("geometry")
	}

	$: if (material) on_material()

	function on_material() {
		changed.push("material")
	}

	$: if (mesh || material || geometry) handle_prop_changes()

	function handle_prop_changes() {
		const geometry_changed = changed.includes("geometry")
		const material_changed = changed.includes("material")

		if (geometry_changed) {
			// apply material
			if (mesh && mesh.geometry !== geometry) {
				mesh.geometry = geometry
				geometry_ref = geometry
				if (mesh.userData.box) mesh.userData.box.update()
			}
		} else {
			// extracted_geometry doesn't need to be applied
			if (geometry_ref !== extracted_geometry) {
				geometry_ref = extracted_geometry
				if (mesh.userData.box) mesh.userData.box.update()
			}
		}

		if (material_changed) {
			// apply material
			if (mesh && mesh.material !== material) {
				mesh.material = material
				material_ref = material
				refresh_material()
			}
		} else {
			// extracted_material doesn't need to be applied
			if (material_ref !== extracted_material) {
				material_ref = extracted_material
				refresh_material()
			}
		}
	}

	/** Recreates `sMat` with the current `material_ref` reference and applies the `mat` prop object to it. */
	function refresh_material(): void {
		sMat = new SvelthreeProps(material_ref)
		if (sMat && mat) sMat.update(mat)
		// TODO  Check using `material_needs_update()` here.
	}

	// Determining 'parent' if 'mesh' instance has to be created first / was not provided on initialization ('create' is true).
	$: if (mesh && create && scene && !our_parent) set_parent()

	function set_parent() {
		// get the instance that was shared to us as our 'parent' or use fallback.

		our_parent = getContext("parent") || scene

		// share created object (three) instance to all children (slots) as 'parent'.
		setContext("parent", mesh)
	}

	//  IMPORTANT  TODO
	// - see https://github.com/vatro/svelthree/issues/114
	// - see https://github.com/vatro/svelthree/issues/103

	$: if (mesh && create && our_parent_shadow_dom_el === undefined) {
		our_parent_shadow_dom_el = getContext("parent_shadow_dom_el") || scene_shadow_dom_el
	}

	//  IMPORTANT  TODO
	// - see https://github.com/vatro/svelthree/issues/114
	// - see https://github.com/vatro/svelthree/issues/103

	$: if (our_parent_shadow_dom_el !== undefined) {
		// SVELTEKIT  SSR /
		if (browser) create_shadow_dom()
	}

	function create_shadow_dom(): void {
		// create / recreate and share our own shadow_dom_el as parent_shadow_dom_el
		shadow_dom_el = recreate_shadow_dom_el(shadow_dom_el, our_parent_shadow_dom_el, button, link, c_name)

		if (shadow_dom_el) {
			setContext("parent_shadow_dom_el", shadow_dom_el)
		} else {
			if (!shadow_dom_el) console.error(`SVELTHREE > ${c_name} : 'shadow_dom_el' was not created!`, shadow_dom_el)
		}
	}

	// accessability -> shadow dom focusable
	export let tabindex: number = undefined

	$: if (shadow_dom_el && tabindex !== undefined) {
		shadow_dom_el.tabIndex = tabindex
	}

	// accessability -> shadow dom wai-aria
	export let aria: Partial<ARIAMixin> = undefined

	$: if (shadow_dom_el && aria !== undefined) {
		for (const key in aria) {
			if (key === "ariaLabel") {
				// add specified `ariaLabel` as text to shadow DOM `<div>` element ONLY (for better reader support / indexing (?))
				if (!link && !button) {
					//  TODO  RECONSIDER  needs to be tested more, may be obsolete (?).
					shadow_dom_el.innerText += `${aria[key]}`
				}
			}

			shadow_dom_el[key] = aria[key]
		}
	}

	// this reactive statement willl be triggered on any 'mesh' instance change (also e.g. `mesh.foo = value`)
	$: if (mesh) if$_instance_change(mesh, our_parent, mesh_uuid, create, "mesh", name, handle_instance_change)

	/** Called from by the `if$_instance_change` logic if needed. */
	function handle_instance_change(): void {
		let old_raycast = false
		let old_block = false

		if ((mesh_uuid && mesh.uuid !== mesh_uuid) || !mesh_uuid) {
			const uuid_to_remove: string = mesh_uuid || mesh.uuid
			const old_instance: THREE_Object3D = find_in_canvas($svelthreeStores[sti].scenes, uuid_to_remove)

			remove_instance(old_instance, "mesh", mesh, self)

			// remove `old_instance` from raycast if needed
			if (raycast.includes(old_instance)) {
				old_raycast = true
				old_block = old_instance.userData.block
				raycast.splice(old_instance.userData.index_in_raycast, 1)
			}

			if (props) sProps = new SvelthreeProps(mesh)
		}

		set_initial_userdata(mesh, self)

		// add 'mesh' (provided instance) to raycast if needed
		if (old_raycast) {
			if (!raycast.includes(mesh)) {
				mesh.userData.block = old_block // will this somehow be handeled automatically?
				raycast.push(mesh)
			}
		}

		our_parent.add(mesh)
		mesh_uuid = mesh.uuid

		if (verbose && log_dev) {
			console.debug(
				...c_dev(c_name, `${mesh.type} was added to ${our_parent.type}!`, {
					mesh,
					scene,
					total: scene.children.length
				})
			)
		}
	}

	/** Override object's `.matrixAutoUpdate` set (*on initialzation*) by scene's `.matrixAutoUpdate` (*default is `true`*). Also: `mau` can be changed on-the-fly.*/
	export let mau: boolean = undefined
	$: if (mesh) mesh.matrixAutoUpdate = scene.matrixAutoUpdate
	$: if (mesh && mau !== undefined) mesh.matrixAutoUpdate = mau

	$: if (mesh && name) mesh.name = name
	$: if (shadow_dom_el && name) shadow_dom_el.dataset.name = name

	let sMat: SvelthreeProps

	$: if (!sMat) {
		if (mesh.material) {
			sMat = new SvelthreeProps(mesh.material)
		}
	}

	// Generic Material props
	// COOL!  This works now! 'mat' shorthand attribute will give us proper intellisense (props list) for the assigned 'material'!
	// TODO : Implement handling of multiple `Material`s, atm only single `Material` is supported.
	/** **shorthand** attribute (`Object`) for setting writable properties of the assigned `Material`. */
	export let mat: Mat<AssignedMaterial> = undefined

	$: if (mat && sMat) {
		const updated_keys: string[] = sMat.update(mat)
		if (updated_keys.length) material_needs_update()
	}

	function material_needs_update(): void {
		const m: Material = (material as Material) || (mesh.material as Material)
		m.needsUpdate = true
	}

	/** ☝️ `matrix` **shorthand** attribute overrides ( *are ignored* ) `pos`, `rot`, `quat`, `scale` and `lookAt` 'shorthand' attributes! */
	export let matrix: Matrix4 | Parameters<Matrix4["set"]> = undefined

	const w_sh = PropUtils.getShortHandAttrWarnings(`SVELTHREE > ${c_name} >`)

	let sProps: SvelthreeProps

	// IMPORTANT  `props` will be overridden by 'shorthand' attributes!
	/** **shorthand** attribute for setting properties using key-value pairs in an `Object`. */
	export let props: { [P in keyof MeshProperties]: MeshProperties[P] } = undefined

	$: if (!sProps && mesh && props) sProps = new SvelthreeProps(mesh)
	$: if (props && sProps) update_props()
	function update_props() {
		if (verbose && log_rs) console.debug(...c_rs(c_name, "props", props))
		sProps.update(props)
	}

	// IMPORTANT  following 'shorthand' attributes will override `props` attribute!

	/** **shorthand** attribute for setting the `position` property. */
	export let pos: Vector3 | Parameters<Vector3["set"]> = undefined
	$: !matrix && mesh && pos ? set_pos() : pos && mesh ? console.warn(w_sh.pos) : null
	function set_pos() {
		if (verbose && log_rs) console.debug(...c_rs(c_name, "pos", pos))
		PropUtils.setPositionFromValue(mesh, pos)
	}

	/** **shorthand** attribute for setting the `rotation` property. */
	export let rot:
		| Euler
		| Parameters<Euler["set"]>
		| Quaternion
		| Parameters<Quaternion["set"]>
		| Vector3
		| Parameters<Vector3["set"]> = undefined
	$: !matrix && !quat && mesh && rot ? set_rot() : rot && mesh ? console.warn(w_sh.rot) : null
	function set_rot() {
		if (verbose && log_rs) console.debug(...c_rs(c_name, "rot", rot))
		PropUtils.setRotationFromValue(mesh, rot)
	}

	/** **shorthand** attribute for setting the `quaternion` property. */
	export let quat: Quaternion | Parameters<Quaternion["set"]> = undefined
	$: !matrix && mesh && quat ? set_quat() : quat && mesh ? console.warn(w_sh.quat) : null
	function set_quat() {
		if (verbose && log_rs) console.debug(...c_rs(c_name, "quat", quat))
		PropUtils.setQuaternionFromValue(mesh, quat)
	}

	export let scale: Vector3 | Parameters<Vector3["set"]> = undefined
	$: !matrix && mesh && scale ? set_scale() : scale && mesh ? console.warn(w_sh.scale) : null
	function set_scale() {
		if (verbose && log_rs) console.debug(...c_rs(c_name, "scale", scale))
		PropUtils.setScaleFromValue(mesh, scale)
	}

	/** */
	export let lookAt: Vector3 | Parameters<Vector3["set"]> | THREE_Object3D = undefined
	$: !matrix && mesh && lookAt ? set_lookat() : lookAt && mesh ? console.warn(w_sh.lookAt) : null
	function set_lookat() {
		if (verbose && log_rs) console.debug(...c_rs(c_name, "lookAt", lookAt))
		PropUtils.setLookAtFromValue(mesh, lookAt)
	}

	// IMPORTANT  `matrix` 'shorthand' attribute will override all other transforms ('shorthand' attributes)!
	$: if (matrix && mesh) set_matrix()
	function set_matrix(): void {
		if (verbose && log_rs) console.debug(...c_rs(c_name, "matrix", matrix))
		PropUtils.setMatrixFromValue(mesh, matrix)
	}

	export let castShadow: boolean = undefined
	$: if (castShadow !== undefined && mesh) mesh.castShadow = castShadow

	export let receiveShadow: boolean = undefined
	$: if (receiveShadow !== undefined && mesh) mesh.receiveShadow = receiveShadow

	/** The root scene -> `scene.parent = null`. */
	let root_scene: THREE_Scene | null = undefined
	let root_scene_obj = { value: undefined }

	$: if (root_scene === undefined) {
		root_scene = get_root_scene(getContext("scene"))
		root_scene_obj.value = root_scene
	}

	$: if (mesh && root_scene) {
		mesh.userData.root_scene = root_scene
	}

	type BoxHelperParams = ConstructorParameters<typeof BoxHelper>
	export let boxParams: RemoveFirst<BoxHelperParams> = undefined
	/** Creates and adds a `BoxHelper`. */
	export let box: boolean = undefined

	/** Removes `WebGLRenderer` `"update_helpers"` event listener. */
	let remove_update_box_on_render_event: () => void = undefined

	$: if (box && mesh && !mesh.userData.box) add_box_helper()
	$: if (!box && mesh?.userData.box) remove_box_helper()

	function add_box_helper() {
		if (boxParams) {
			mesh.userData.box = new BoxHelper(mesh, ...boxParams)
		} else {
			mesh.userData.box = new BoxHelper(mesh)
		}

		mesh.userData.box.visible = false
	}

	// update and show box on next frame
	$: if (box && mesh && mesh.userData.box && $svelthreeStores[sti].rendererComponent && root_scene) {
		apply_box()
	}

	function apply_box(): void {
		if (!mesh.userData.box.parent) {
			// add all boxes to the root scene!
			if (root_scene) {
				root_scene.add(mesh.userData.box)
			} else {
				console.error(`SVELTHREE > ${c_name} > Cannot add box to 'root_scene'!`, root_scene)
			}
		}

		// update box and make it visible
		mesh.userData.box.update()
		mesh.userData.box.visible = true

		// start updating
		if (!remove_update_box_on_render_event) {
			remove_update_box_on_render_event = $svelthreeStores[sti].rendererComponent.$on(
				"update_helpers",
				update_box
			)
		}
	}

	function update_box(): void {
		// `mesh` may have been nullified by `clear()`
		if (mesh) mesh.userData.box.update()
	}

	function remove_box_helper(): void {
		if (remove_update_box_on_render_event) {
			remove_update_box_on_render_event()
			remove_update_box_on_render_event = null
		}

		// `mesh` may have been nullified by `clear()`
		if (mesh?.userData.box?.parent) {
			mesh.userData.box.parent.remove(mesh.userData.box)
			mesh.userData.box = null
		}
	}

	/** Make component's three.js object interactive -> enable raycasting, `on:<event_name>` directives and `on_<event_name>` internal actions. */
	export let interact: boolean = undefined

	/**
	Adds component's three.js object instance to the `raycast` array even if it's not set to `interact` ( _no interaction listeners_ ).
	* This way the object acts as a pure _interaction occluder / blocker_ -> will be detected / intersected by `Raycaster`'s ray.
	* 
	* Setting the `block` prop makes sense only if the `interact` prop is not set / set to `false`.  
	* In case `interact` prop is set / set to `true`, but no e.g. `on:<event_name>` directives or `on_<event_name>` internal actions are set,
	* the object will automatically become an _interaction occluder / blocker_.
   */
	export let block = false

	const interaction_on_clear = {
		interact: undefined,
		block: undefined
	}

	$: if (mesh) restore_interaction_props()
	async function restore_interaction_props(): Promise<void> {
		//console.warn(`comp '${name}' restore_interaction_props!`, { mesh, mesh_uuid, interact: mesh.userData.interact })
		if (typeof interaction_on_clear.interact === "boolean") {
			await tick()

			//console.warn(`comp '${name}' restoring 'interact' prop!`, interaction_on_clear.interact)
			interact = interaction_on_clear.interact
			interaction_on_clear.interact = null

			if (interaction_on_clear.block !== undefined && interaction_on_clear.block !== null) {
				//console.warn(`comp '${name}' restoring 'block' prop!`, interaction_on_clear.block)
				block = interaction_on_clear.block
				interaction_on_clear.block = null
			}
		}
	}

	let interactive: boolean = undefined
	const canvas_interactivity: Writable<{ enabled: boolean }> = getContext("canvas_interactivity")

	$: interactive = $canvas_interactivity.enabled

	let interactionEnabled: boolean = undefined
	$: interactionEnabled = interactive && interact

	//  IMPORTANT  not reactive
	const raycast: RaycastArray = getContext("raycast")

	// Reactively ENABLE raycasting to the created three.js instance. Only `interact` is set and `block` is false (default).
	// + `block` will be changed automatically based on pointer listeners total count via `SvelthreeInteraction` component.
	$: if (interactionEnabled && raycast && !block) {
		if (!raycast.includes(mesh)) {
			mesh.userData.block = false
			raycast.push(mesh)
		} else {
			mesh.userData.block = false
		}
	}

	// Reactively ENABLE raycasting to the created three.js instance -> 'interaction occluder / blocker'.
	// Only `block` is set / `true` but no `interact` / set to `false`. Since `interact` is `false`,
	// `block` will NOT be changed via `SvelthreeInteraction` component (not rendered).
	$: if (!interactionEnabled && raycast && block) {
		if (!raycast.includes(mesh)) {
			mesh.userData.block = true
			raycast.push(mesh)
		} else {
			mesh.userData.block = true
		}
	}

	// Reactively DISABLE raycasting to the created three.js instance. Neither `block` nor `interact` are set / are both `false`.
	// Since `interact` is `false`, `block` will NOT be changed via `SvelthreeInteraction` component (not rendered).
	$: if (!interactionEnabled && raycast && !block) {
		if (raycast.includes(mesh)) {
			raycast.splice(mesh.userData.index_in_raycast, 1)
			mesh.userData.block = false
		}
	}

	/** `SvelthreeInteraction` component reference used for reactive listener management only. */
	let interaction_comp = undefined

	/**
	 * **svelthree** replacement for [`$on`](https://svelte.dev/docs#run-time-client-side-component-api-$on), does basically the same,
	 * but it doesn't return a function for removal of the listener (_like Svelte native does_), instead use `.onx(type, callback)` syntax.
	 * Needed for **reactive** interaction listener management -> _internal svelthree functionality_.
	 *
	 * ☝️ _Can be used with **interactive components only** -> `interact` prop has to be `true`._
	 */
	export const on = async (type: any, callback: any): Promise<void> => {
		if (interact) {
			if (!interaction_comp || !shadow_dom_el) await tick()

			self.$on(type, callback)
			interaction_comp.update_listeners = true
		} else {
			console.error(
				"SVELTHREE > Mesh > on : You can call the '.on(...)' function with interactive components only! Component's 'interact' prop has to be 'true'."
			)
		}
	}

	/**
	 * **svelthree** replacement for the _event listener removal function_ returned by [`$on`](https://svelte.dev/docs#run-time-client-side-component-api-$on), does basically the same,
	 * needed for **reactive** interaction listener management -> _internal svelthree functionality_. It additionaly allows programmatic removal of all callbacks of a certain type and
	 * programmatic removal of 'forwarding' directives (no handlers) like `on:click`.
	 *
	 * ☝️ _Can be used with **interactive components only** -> `interact` prop has to be `true`._
	 */
	export const onx = async (type: any, callback: any): Promise<void> => {
		if (interact) {
			if (!interaction_comp || !shadow_dom_el) await tick()

			const cbacks = self.$$.callbacks[type]
			if (callback) {
				const index = cbacks.indexOf(callback)
				if (index !== -1) cbacks.splice(index, 1)
			} else {
				// allows e.g. onx("click") -> will remove all callbacks and the callback type itself
				// this way we can also programatically delete 'forwarding' directives (no handlers) like `on:click`
				self.$$.callbacks[type].length = 0
				delete self.$$.callbacks[type]
			}

			interaction_comp.update_listeners = true
		} else {
			console.error(
				"SVELTHREE > Mesh > onx : You can call the '.onx(...)' function with interactive components only! Component's 'interact' prop has to be 'true'!"
			)
		}
	}

	/** Interaction modifiers. */
	export let modifiers: SvelthreeModifiersProp = undefined

	export let on_click: SvelthreePointerEventHandler = undefined
	$: if (on_click !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_pointerup: SvelthreePointerEventHandler = undefined
	$: if (on_pointerup !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_pointerdown: SvelthreePointerEventHandler = undefined
	$: if (on_pointerdown !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_pointerover: SvelthreePointerEventHandler = undefined
	$: if (on_pointerover !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_pointerout: SvelthreePointerEventHandler = undefined
	$: if (on_pointerout !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_pointermove: SvelthreePointerEventHandler = undefined
	$: if (on_pointermove !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_pointermoveover: SvelthreePointerEventHandler = undefined
	$: if (on_pointermoveover !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_keydown: SvelthreeKeyboardEventHandler = undefined
	$: if (on_keydown !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_keypress: SvelthreeKeyboardEventHandler = undefined
	$: if (on_keypress !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_keyup: SvelthreeKeyboardEventHandler = undefined
	$: if (on_keyup !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_focus: SvelthreeFocusEventHandler = undefined
	$: if (on_focus !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_blur: SvelthreeFocusEventHandler = undefined
	$: if (on_blur !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_focusin: SvelthreeFocusEventHandler = undefined
	$: if (on_focusin !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_focusout: SvelthreeFocusEventHandler = undefined
	$: if (on_focusout !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_wheel: SvelthreeWheelEventHandler = undefined // ->  TODO  implement
	$: if (on_wheel !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	export let on_wheelover: SvelthreeWheelEventHandler = undefined // -> TODO  implement
	$: if (on_wheelover !== undefined && interaction_comp && shadow_dom_el) {
		interaction_comp.update_listeners = true
	}

	/** Animation logic to be performed with the (three) object instance created by the component. */
	export let animation: SvelthreeAnimationFunction = undefined

	let animationEnabled = false
	$: if (animation) animationEnabled = true

	/** Immediately start provided animation, default: `false`. Alternative: `<component_reference>.start_animation()` or shorter `.start_ani()`. */
	export let aniauto: boolean = undefined

	let ani: SvelthreeAnimation
	$: if (animation && animationEnabled) ani = new SvelthreeAnimation(scene, mesh, animation, aniauto)

	let currentSceneActive = undefined
	$: currentSceneActive = $svelthreeStores[sti].scenes[scene.userData.index_in_scenes]?.isActive
	$: if (ani && currentSceneActive !== undefined) ani.onCurrentSceneActiveChange(currentSceneActive)

	/** Removes the (three) instance created by / provided to the component from it's parent. */
	export const remove_instance_from_parent = async (): Promise<boolean> => {
		const removed: boolean = remove_instance(mesh, "mesh")
		return removed
	}
	/**
	 * Same as `remove_instance_from_parent()` just shorter syntax.
	 * Removes the (three) instance of the object created by the component from it's parent.
	 */
	export const remove = remove_instance_from_parent

	/** Returns the (three) instance of the object created by the component. */
	export const get_instance = (): THREE_Mesh => mesh

	/** Returns the `animation` object. */
	export const get_animation = (): any => ani.getAnimation()
	/** Same as `get_animation()` just shorter syntax. Returns the `animation` object. */
	export const get_ani = get_animation

	/** Starts the `animation` object. */
	export const start_animation = (): void => ani.startAni()
	/** Same as `start_animation()` just shorter syntax. Starts the `animation` object. */
	export const start_ani = start_animation

	/** Sets `focus()` on the component / it's shadow dom element. */
	export const focused = (): void => shadow_dom_el.focus()

	/**
	 * Primarily for internal usage. Clears all references to the currently managed three.js instance.
	 * Called by `remove_instance(...)` / `clear_old_component()` if the instance has been
	 * assigned to some other component (_before_).
	 */
	export const clear = () => {
		//console.warn(`CLEAR! -> ${name}`)

		interaction_on_clear.interact = interact
		interaction_on_clear.block = block
		interact = null

		mesh = null

		geometry = null
		material = null

		// IMPORTANT //
		// has to be set to `null`, `undefined` would set `mesh_uuid` if a cleared component recevies a mesh
		// we don't want that, beacuse then the `handle_instance_change` wouldn't be triggered!
		mesh_uuid = null
	}

	import type { SvelthreeComponentShadowDOMChild } from "../types/types-extra"
	const generated_children: SvelthreeComponentShadowDOMChild[] = []
	const user_created_children: SvelthreeComponentShadowDOMChild[] = []

	/**
	 * Pushes a user-created (_e.g. via `new Mesh({...})`_) or an internally generated / created (e.g. via `SvelthreeGLTF.apply(...)`) `svelthree`-component
	 * to a corresponding Array containing all user-created / internally generated (_registered_) child components, in order for them to be destroyed at the same time
	 * the parent component gets destroyed (_`onDestroy`_). See also `comp_ref.get_user_created_children()` and `comp_ref.get_generated_children()`.
	 */
	export const register_child_component = (
		component: SvelthreeComponentShadowDOMChild,
		generated?: boolean
	): SvelthreeComponentShadowDOMChild[] => {
		if (generated) {
			if (!generated_children.includes(component)) {
				generated_children.push(component)
			}

			return generated_children
		} else {
			if (!user_created_children.includes(component)) {
				user_created_children.push(component)
			}

			return user_created_children
		}
	}

	function destroy_registered_child_components(arr: SvelthreeComponentShadowDOMChild[]) {
		if (arr.length) {
			for (let i = 0; i < arr.length; i++) {
				const child_comp: SvelthreeComponentShadowDOMChild = arr[i]
				if (child_comp) child_comp.$destroy()
				arr[i] = null
			}

			arr.length = 0
		}
	}

	export const get_user_created_children = (): SvelthreeComponentShadowDOMChild[] => user_created_children
	export const get_generated_children = (): SvelthreeComponentShadowDOMChild[] => generated_children

	/** **Completely replace** `onMount` -> any `onMount_inject_before` & `onMount_inject_after` will be ignored.
	 * _default verbosity will be gone!_ */
	export let onMount_replace: (args?: any) => any = undefined

	onMount(
		onMount_replace
			? async () => onMount_replace(_self)
			: async () => {
					if (verbose && log_lc && (log_lc.all || log_lc.om)) {
						console.info(...c_lc(c_name, "onMount"))
					}

					if (verbose && log_mau) {
						console.debug(
							...c_mau(c_name, "onMount : mesh.", {
								matrixAutoUpdate: mesh.matrixAutoUpdate,
								matrixWorldNeedsUpdate: mesh.matrixWorldNeedsUpdate
							})
						)
					}
			  }
	)

	/** **Inject** functionality **before** component's existing `onDestroy` logic.
	 * _default verbosity not affected._ */
	export let onDestroy_inject_before: (args?: any) => any = undefined

	/** **Inject** functionality **after** component's existing `onDestroy` logic.
	 * _default verbosity not affected._ */
	export let onDestroy_inject_after: (args?: any) => any = undefined

	/** **Completely replace** `onDestroy` -> any `onDestroy_inject_before` & `onDestroy_inject_after` will be ignored.
	 * _default verbosity will be gone!_ */
	export let onDestroy_replace: (args?: any) => any = undefined

	onDestroy(
		onDestroy_replace
			? async () => onDestroy_replace(_self)
			: async () => {
					if (verbose && log_lc && (log_lc.all || log_lc.od)) {
						console.info(...c_lc(c_name, "onDestroy"))
					}

					if (verbose && log_mau) {
						console.debug(
							...c_mau(c_name, "onDestroy : mesh.", {
								matrixAutoUpdate: mesh.matrixAutoUpdate,
								matrixWorldNeedsUpdate: mesh.matrixWorldNeedsUpdate
							})
						)
					}

					if (onDestroy_inject_before) onDestroy_inject_before()

					remove_box_helper()
					if (ani) ani.destroyAnimation()

					destroy_registered_child_components(generated_children)
					destroy_registered_child_components(user_created_children)

					if (onDestroy_inject_after) onDestroy_inject_after()
			  }
	)

	/** **Completely replace** `beforeUpdate` -> any `beforeUpdate_inject_before` & `beforeUpdate_inject_after` will be ignored.
	 * _default verbosity will be gone!_ */
	export let beforeUpdate_replace: (args?: any) => any = undefined

	beforeUpdate(
		beforeUpdate_replace
			? async () => beforeUpdate_replace(_self)
			: async () => {
					if (verbose && log_lc && (log_lc.all || log_lc.bu)) {
						console.info(...c_lc(c_name, "beforeUpdate"))
					}

					if (verbose && log_mau) {
						console.debug(
							...c_mau(c_name, "beforeUpdate : mesh.", {
								matrixAutoUpdate: mesh.matrixAutoUpdate,
								matrixWorldNeedsUpdate: mesh.matrixWorldNeedsUpdate
							})
						)
					}
			  }
	)

	/** **Inject** functionality **before** component's existing `afterUpdate` logic.
	 * _default verbosity not affected._ */
	export let afterUpdate_inject_before: (args?: any) => any = undefined

	/** **Inject** functionality **after** component's existing `afterUpdate` logic.
	 * _default verbosity not affected._ */
	export let afterUpdate_inject_after: (args?: any) => any = undefined

	/** **Completely replace** `afterUpdate` -> any `afterUpdate_inject_before` & `afterUpdate_inject_after` will be ignored.
	 * _default verbosity will be gone!_ */
	export let afterUpdate_replace: (args?: any) => any = undefined

	afterUpdate(
		afterUpdate_replace
			? async () => afterUpdate_replace(_self)
			: async () => {
					if (verbose && log_lc && (log_lc.all || log_lc.au)) {
						console.info(...c_lc(c_name, "afterUpdate"))
					}

					if (verbose && log_mau) {
						console.debug(
							...c_mau(c_name, "afterUpdate : mesh.", {
								matrixAutoUpdate: mesh.matrixAutoUpdate,
								matrixWorldNeedsUpdate: mesh.matrixWorldNeedsUpdate
							})
						)
					}

					if (afterUpdate_inject_before) afterUpdate_inject_before()

					// Update local matrix after all (props) changes (async microtasks) have been applied.
					if (mesh && !mesh.matrixAutoUpdate) mesh.updateMatrix()

					if (verbose && !mesh.matrixAutoUpdate && log_mau) {
						console.debug(
							...c_mau(c_name, "afterUpdate : mesh.", {
								matrixAutoUpdate: mesh.matrixAutoUpdate,
								matrixWorldNeedsUpdate: mesh.matrixWorldNeedsUpdate
							})
						)
					}

					if ($svelthreeStores[sti].rendererComponent?.mode === "auto") {
						// prevent an additional component update by not accessing the `root_scene` prop directly.
						root_scene_obj.value.userData.dirty = true
						$svelthreeStores[sti].rendererComponent.schedule_render_auto(root_scene)
					}

					if (afterUpdate_inject_after) afterUpdate_inject_after()
			  }
	)
</script>

<slot />

{#if $svelthreeStores[sti].renderer && $svelthreeStores[sti].renderer.xr.enabled === false && interact}
	<SvelthreeInteraction
		bind:this={interaction_comp}
		{shadow_dom_el}
		{modifiers}
		{dispatch}
		obj={mesh}
		parent={self}
		{interactionEnabled}
		{log_dev}
		{log_lc}
	/>
{/if}
